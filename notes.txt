

GIT OFFICIAL DOC

https://git-scm.com/doc

GIT BASICS

Working directory -> root folder. Where .git is. Local repository
Staging area -> files add/prepared to be commited
Index -> = staging area
Origin -> remote repository URL
HEAD -> Current branch pointer. HEAD points to actual branch and branch points to a commit (usually last commit) 
Detached HEAD -> When HEAD points to an old commit of the current branch

GIT COMMANDS

git init -> inititate git repository on that folder

git status -> show status of the actual local git repository

git log -> repository log info
git log --oneline -> repository log info abbreviated to one line per commit

GIT COMMIT

    git add . -> add to staging all files with changes
    git add "file" -> add file to staging

    git commit -> open default text editor and wait until save and exit to commit
    git commit -m "commit description starting with imperative verb prefered" -> most common use of commit
    git commit --amend -> recommit previous commit. It opens default text editor
    git commit -a -m "commit message" -> add all modified files and commit in one step

GIT IGNORE 

official doc -> https://www.git-scm.com/docs/gitignore

tool for default gitignore files -> https://www.toptal.com/developers/gitignore/

create .gitignore on root folder git repository to avoid git to track specificied files or folders

BRANCHES

    git branch -> list branches from the repository
    git branch "new branch name" -> create a branch from the current HEAD
    git switch "branch name to switch" -> switch to that branch. If you have not that branch locally, but you do remotely, it will connect to remote branch and create same locally
    git switch -c "new branch name" -> create a new branch and switch
    git checkout "branch name" -> same function as switch. It is the older way. Still common though
    git checkout remotename/branchname -> point to that remote branch
    git branch -d "branch name" -> Delete branch. You cant do it if your are in this branch
    git branch -m "branch name to rename" "branch new name"-> rename name of a branch
    git branch -r -> show remote branches

MERGE

    git merge "branch to merge from" -> merges the commits from a branch to actual HEAD
    ## if your feature branch just has commits that master doesnt and master does not have any new commit, i will be a Fast Forwards merge. I will just move master to feature branch HEAD.

    ## my  feature branche has two commits, master, where i am going to merge, has one new commits. Master commit affects to a file that is not in conflict with anu of my commit files. When git merge, git will do a merge commit, will merge both branches, but will add a commit with a comment of "Merge branch 'branch name'" at head of master.

    ##If master has a commit that involves a file that is in my feature branch commit, when merge, there will be a conflict. Git will ask me to choose a version. Every file with conflcit will have some tags to refer the conflict. 

	##Tags are <<<<< HEAD
	## changes of my HEAD
	## =================
 	## changes from the other branch
	## <<<< branch name 

REBASE

    #Is another way to merge branches but with difference es with merge command 
    #It can be nice to uso for cleanup commit history 

    #Rebase vs Merge
    #When we use git merge in a large team or a concurrent project, we have to update our feature branch often. That makes commit log to get dirty. It is not really smooth.
    #With rebase, if master changed we can use it to re base out branch commits just after the new commits coming from master. Not in the middle with merge. It is like if you created your feature branch with that last master version.

    #The GOLDEN RULE:
    # DO NOT REBASE THE MASTER BRANCH FROM ANOTHER BRANCH because that history is sharted with other persons and then can be difficult to restore
    # Just rebase from master when you are in your feature branch

    git rebase branchname -> bring new commits from branchname and rewrite them before my feature branch commits
    #if conflicts, i have to choose a version as we do with merge. After that, git add that files and 
    git rebase --continue -> continue with rebase when were conflicts
    git rebase --abort -> abort rebase operation

    #interactive rebase
    #entering this mode ables us to edit commits, add files, drop commit..etc from our HEAD to a specific commit
    git rebase -i 7dcd78a -> Enters in interactive rebase mode, and shows all commits from specified to HEAD. For every commit, we can do an action. All actions are listed down


DIFF

	#shows the difference between two spots of the repository. it could be between working directory, HEAD, staged files, commits, branches...etc.

	git diff -> showsw difference between working directiory and staged files
	git diff HEAD -> shows difference between working directory and HEAD (last commit of actual branch)
	git diff HEAD filename.txt -> shows difference between staged file and same file in HEAD
	git diff --staged -> shows difference between staged files and HEAD
	 


GIT STASH

    #You can stash changes of working directory working + stage area and change to another branch if needed.
    #it is like to save a version on a memory, and if we want to recover those changes back, we just use unstash

    git stash -> save changes and rollback to previous commit. Now you can change to another branch of commit without problemas.
    git stash pop -> apply stashed changes to current version and remove stash
    git stash apply -> apply stashed changes to current version and dont remove stash
    git stash list -> list the stashes. You can stash several changes in distinct stashes


UNDO changes and time travel 

    #We can checkout to a previous version. To a previous commit in order to see how the code was at that point. Or we could even
    #create a new branch based on a previous commit. For that, we checkout to that commit, pointing HEAD to that branch -> commit.

    git checkout "commit-hash" -> set HEAD to point to that branch -> commit
    git checkout HEAD~n -> same as before but you can checkout by HEAD number. Being HEAD the last, 1 previous and so forth
    git switch "branch name" -> to recover the real HEAD of that branch where we checkedout to previous commit
    git checkout HEAD -> discard changes from working directory and reset to HEAD version
    git restore "file name" -> reset file to HEAD version 
    git restore --staged "filename" -> unstage file that was staged. It doesnt restore the content of the file, just removes it from staged area
    git reset "commit-hash" -> it will remove commits between actual HEAD and that commit. Then it points HEAD to that commit.
    #Dont use git reset if you are working with other people, because it will be hard to concile 
    git reset --hard "commit-hash" -> same as before, but, it also revert working directory to state of the commit. WARNING! you will lose your files and changes.
    git revert "commit-hash" -> it will also undo changes, but instead of remove any commit from branch, it will create a new commit with reverted version. Use revert instead of reset if you ever pushed to an origin repo that other people may be using.

REMOTE 

    #It is used to connect a local repo to a remote repo. Usually to github , bitbucket, gitlab...etc

    git remote add "name" "url remote repo" -> connect local repo to a remote one. Usually name param is origin. Usually git push origin master
    git remote rename "oldname" "newname" -> just rename de remote repo

PUSH 

    git push "remotename" "branchname" -> update the branch in remote with commits in your local + 
    #You dont really have to be on the brancah you want to push

FETCH

    #It will update the local repository from the remote, but wont touch my working directory. It update my local origin/master (for example)
    #We could for example, fetch and then work with the last version of remote if we dont have internet and of course, no one pushed any commit to remote repo

    git fetch remotename -> bring remote changes to local repo
    git fetch remotename brachname -> bring specific branch changes from remote


PULL

    #It will bring changes from remote, but also, will merge them into out working directory. Into our HEAD.
    #pulling can provoke conflicts between your working directory and remote changes. You will need to resolve then to choose a final version for your working directory

    git pull remotename branchname -> it actually will fetch to local repo + merge to our working directory
    git pull -> it will do the same, just bringing changes from the remote default tracking branch.


GIT WORKFLOWS

    #Centralized - only one branch (master)
    #Not ideal for teams where you want to share code, because u have to pull and push to master for that. 
    #as it is constantly commited by others, devs have to resolve conflicts frequently
    #Not the best option for experiments

    #Feature branches. Create a branch per feature/fix/anychange
    #Most common flow. 
        #You can share code just by switching to a branch
        #master wont have broken or experimental code
        #master will have a real history commits

    #Fork & Clone
    #Used mainly for big open source projects when we dont have permisions to push. 
    #So we can fork a repo, creating then an own copy of the repo. There, we can push without problems and create pull requests to the original project. Owners of it can accept and merge our changes. 
    #That is the way of collaborating with open source projects, for example.

